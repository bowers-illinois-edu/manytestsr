[
  {
    "objectID": "getting-started.html",
    "href": "getting-started.html",
    "title": "Getting Started with manytestsr",
    "section": "",
    "text": "The manytestsr package implements hierarchical testing procedures for detecting treatment effects across multiple experimental blocks. Instead of testing each block independently (which inflates Type I error) or testing everything together (which reduces power), hierarchical testing:\n\nSplits blocks into groups based on similarity or pre-specified structure\nTests groups at each level of the hierarchy\n\nControls error rates while maintaining power to detect heterogeneous effects\n\nThis is especially useful for: - Multi-site experiments with varying treatment effects - A/B tests across different user segments\n- Clinical trials with multiple centers - Any setting with clustered/blocked experimental units"
  },
  {
    "objectID": "getting-started.html#what-is-hierarchical-testing",
    "href": "getting-started.html#what-is-hierarchical-testing",
    "title": "Getting Started with manytestsr",
    "section": "",
    "text": "The manytestsr package implements hierarchical testing procedures for detecting treatment effects across multiple experimental blocks. Instead of testing each block independently (which inflates Type I error) or testing everything together (which reduces power), hierarchical testing:\n\nSplits blocks into groups based on similarity or pre-specified structure\nTests groups at each level of the hierarchy\n\nControls error rates while maintaining power to detect heterogeneous effects\n\nThis is especially useful for: - Multi-site experiments with varying treatment effects - A/B tests across different user segments\n- Clinical trials with multiple centers - Any setting with clustered/blocked experimental units"
  },
  {
    "objectID": "getting-started.html#quick-start",
    "href": "getting-started.html#quick-start",
    "title": "Getting Started with manytestsr",
    "section": "Quick Start",
    "text": "Quick Start\n\nLoad Package and Data\n\nlibrary(manytestsr)\nlibrary(data.table)\nlibrary(dplyr)\n\n# Load built-in example data\ndata(example_dat, package = \"manytestsr\")\n\n# Prepare individual-level data\nidat &lt;- as.data.table(example_dat)\n\n# Create block-level summary\nbdat &lt;- idat %&gt;%\n  group_by(blockF) %&gt;%\n  summarize(\n    nb = n(),                    # Block size\n    pb = mean(trt),             # Proportion treated\n    hwt = (nb / nrow(idat)) * (pb * (1 - pb)),  # Harmonic mean weight\n    .groups = \"drop\"\n  ) %&gt;%\n  as.data.table()\n\nprint(paste(\"Data:\", nrow(idat), \"individuals in\", nrow(bdat), \"blocks\"))\n#&gt; [1] \"Data: 1268 individuals in 44 blocks\"\n\n\n\nRun Hierarchical Testing\n\n# Basic hierarchical testing\nresults &lt;- find_blocks(\n  idat = idat,                    # Individual-level data\n  bdat = bdat,                    # Block-level data\n  blockid = \"blockF\",             # Block identifier column\n  splitfn = splitCluster,         # How to split blocks (k-means clustering)\n  pfn = pOneway,                  # Statistical test to use (t-test)\n  fmla = Y1 ~ trtF | blockF,     # Formula: outcome ~ treatment | block\n  splitby = \"hwt\",               # Variable to guide splitting\n  parallel = \"no\",               # Disable parallel processing for demo\n  thealpha = 0.05                # Overall error rate\n)\n\nprint(paste(\"Testing created\", nrow(results$node_dat), \"nodes in the tree\"))\n#&gt; [1] \"Testing created 1 nodes in the tree\"\n\n\n\nFind Significant Effects\n\n# Identify blocks with significant treatment effects\ndetections &lt;- report_detections(results$bdat, fwer = TRUE, alpha = 0.05)\n\n# Summary\ncat(\"Results Summary:\\n\")\n#&gt; Results Summary:\ncat(\"- Total blocks tested:\", nrow(detections), \"\\n\")\n#&gt; - Total blocks tested: 44\ncat(\"- Blocks with significant effects:\", sum(detections$hit, na.rm = TRUE), \"\\n\")  \n#&gt; - Blocks with significant effects: 0\ncat(\"- Detection rate:\", round(mean(detections$hit, na.rm = TRUE) * 100, 1), \"%\\n\")\n#&gt; - Detection rate: 0 %\n\n# Show significant blocks if any found\nif(sum(detections$hit, na.rm = TRUE) &gt; 0) {\n  sig_blocks &lt;- detections[hit == TRUE, .(blockF, pfinalb)]\n  cat(\"\\nSignificant blocks:\\n\")\n  print(sig_blocks)\n}"
  },
  {
    "objectID": "getting-started.html#key-components",
    "href": "getting-started.html#key-components",
    "title": "Getting Started with manytestsr",
    "section": "Key Components",
    "text": "Key Components\n\nSplitting Functions\nChoose how to divide blocks at each step:\n\n# Cluster-based splitting (most common)\nsplitCluster      # Groups similar blocks using k-means\n\n# Pre-specified hierarchical splitting  \nsplitSpecifiedFactor  # Follows predefined hierarchy (e.g., state &gt; district &gt; school)\n\n# Leave-one-out splitting\nsplitLOO          # Focuses on largest/most powerful blocks first\n\n# Equal-sum splitting\nsplitEqualApprox  # Balances total size/weight across groups\n\n\n\nTest Functions\nChoose the statistical test:\n\npOneway       # T-tests (assumes normality)\npIndepDist    # Distance-based tests (robust, recommended)\npWilcox       # Wilcoxon rank-sum tests (ordinal outcomes)\n\n\n\nError Control\nControl Type I error rates:\n\n# Fixed alpha (FWER control)\nalphafn = NULL, thealpha = 0.05\n\n# Sequential FDR control (more powerful)  \nalphafn = alpha_investing, thealpha = 0.05, thew0 = 0.049"
  },
  {
    "objectID": "getting-started.html#example-different-approaches",
    "href": "getting-started.html#example-different-approaches",
    "title": "Getting Started with manytestsr",
    "section": "Example: Different Approaches",
    "text": "Example: Different Approaches\n\nApproach 1: Robust Distance-Based Testing\n\nresults_robust &lt;- find_blocks(\n  idat = idat,\n  bdat = bdat,\n  blockid = \"blockF\",\n  splitfn = splitCluster,\n  pfn = pIndepDist,           # Distance-based test (robust)\n  fmla = Y1 ~ trtF | blockF,\n  splitby = \"hwt\",\n  parallel = \"no\"\n)\n\nrobust_detections &lt;- report_detections(results_robust$bdat)\ncat(\"Robust approach detections:\", sum(robust_detections$hit, na.rm = TRUE), \"\\n\")\n#&gt; Robust approach detections: 8\n\n\n\nApproach 2: Sequential FDR Control\n\nresults_fdr &lt;- find_blocks(\n  idat = idat,\n  bdat = bdat, \n  blockid = \"blockF\",\n  splitfn = splitCluster,\n  pfn = pIndepDist,\n  alphafn = alpha_investing,   # Sequential FDR control\n  fmla = Y1 ~ trtF | blockF,\n  splitby = \"hwt\",\n  parallel = \"no\",\n  thealpha = 0.05,\n  thew0 = 0.049              # Starting \"wealth\"\n)\n\nfdr_detections &lt;- report_detections(results_fdr$bdat, fwer = FALSE)\ncat(\"FDR approach detections:\", sum(fdr_detections$hit, na.rm = TRUE), \"\\n\")\n#&gt; FDR approach detections: 44"
  },
  {
    "objectID": "getting-started.html#visualizing-results",
    "href": "getting-started.html#visualizing-results",
    "title": "Getting Started with manytestsr",
    "section": "Visualizing Results",
    "text": "Visualizing Results\n\nTree Structure\n\nlibrary(ggraph)\nlibrary(ggplot2)\n\n# Create tree visualization\ntree_data &lt;- make_results_tree(results$bdat, block_id = \"blockF\")\ntree_plot &lt;- make_results_ggraph(tree_data$graph)\n\n# Display the tree\ntree_plot + \n  labs(title = \"Hierarchical Testing Tree\") +\n  theme_void()\n\n\n\n\n\n\n\n\n\n\nResults Summary\n\n# Create summary table\nsummary_table &lt;- tree_data$test_summary\nif(!is.null(summary_table) && is.data.frame(summary_table) && nrow(summary_table) &gt; 0) {\n  cat(\"Test Summary:\\n\")\n  print(summary_table)\n} else {\n  cat(\"Tree structure (nodes by depth):\\n\")\n  if(!is.null(tree_data$nodes) && is.data.frame(tree_data$nodes)) {\n    print(tree_data$nodes[, .N, by = depth])\n  } else {\n    cat(\"Tree data structure available but not displayed in simple format.\\n\")\n  }\n}\n#&gt; Tree structure (nodes by depth):\n#&gt;    depth     N\n#&gt;    &lt;int&gt; &lt;int&gt;\n#&gt; 1:     1     1\n#&gt; 2:     2     2"
  },
  {
    "objectID": "getting-started.html#best-practices",
    "href": "getting-started.html#best-practices",
    "title": "Getting Started with manytestsr",
    "section": "Best Practices",
    "text": "Best Practices\n\n1. Data Preparation\n\nEnsure treatment assignment is balanced within blocks\nInclude relevant block-level covariates for splitting\nCalculate appropriate power weights (harmonic mean weights work well)\n\n\n\n2. Method Selection\n\nStart with: splitCluster + pIndepDist + alpha_investing\nFor hierarchical data: Use splitSpecifiedFactor\nFor robustness: Always consider pIndepDist\nFor power: Use sequential procedures (alpha_investing, alpha_saffron)\n\n\n\n3. Interpretation\n\nFocus on blocks identified as significant\nConsider effect sizes, not just p-values\nValidate findings with additional data if possible\n\n\n\nNext Steps\nFor more advanced usage, see the full workflow vignette: - Multiple outcome testing - Custom splitting strategies\n- Parallel processing - Advanced visualization options\nThe hierarchical testing framework provides a principled way to navigate the multiple testing problem while maintaining power to detect heterogeneous treatment effects across experimental blocks."
  },
  {
    "objectID": "hierarchical-testing-workflow.html",
    "href": "hierarchical-testing-workflow.html",
    "title": "Hierarchical Testing with manytestsr",
    "section": "",
    "text": "The manytestsr package implements hierarchical testing procedures for detecting treatment effects across multiple experimental blocks while controlling error rates. This approach is particularly useful when you have:\n\nMultiple experimental units organized in blocks\nHeterogeneous treatment effects across blocks\nNeed to identify which specific blocks show effects\nWant to control family-wise error rate (FWER) or false discovery rate (FDR)\n\nThis vignette walks through the complete workflow from data preparation to results interpretation."
  },
  {
    "objectID": "hierarchical-testing-workflow.html#introduction",
    "href": "hierarchical-testing-workflow.html#introduction",
    "title": "Hierarchical Testing with manytestsr",
    "section": "",
    "text": "The manytestsr package implements hierarchical testing procedures for detecting treatment effects across multiple experimental blocks while controlling error rates. This approach is particularly useful when you have:\n\nMultiple experimental units organized in blocks\nHeterogeneous treatment effects across blocks\nNeed to identify which specific blocks show effects\nWant to control family-wise error rate (FWER) or false discovery rate (FDR)\n\nThis vignette walks through the complete workflow from data preparation to results interpretation."
  },
  {
    "objectID": "hierarchical-testing-workflow.html#loading-the-package-and-data",
    "href": "hierarchical-testing-workflow.html#loading-the-package-and-data",
    "title": "Hierarchical Testing with manytestsr",
    "section": "Loading the Package and Data",
    "text": "Loading the Package and Data\n\nlibrary(manytestsr)\nlibrary(data.table)\nlibrary(dplyr)\nlibrary(ggplot2)\nlibrary(ggraph)\n\n# Load example data\ndata(example_dat, package = \"manytestsr\")\nhead(example_dat)\n#&gt;       id  year   trt    Y1    Y2   trtF place_year_block  place blockF\n#&gt;    &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;num&gt; &lt;num&gt; &lt;fctr&gt;           &lt;char&gt; &lt;char&gt; &lt;fctr&gt;\n#&gt; 1:     1     1     0     0     0      0         A.1.B082      A   B082\n#&gt; 2:     2     3     0     0    12      0         B.3.B094      B   B094\n#&gt; 3:     3     1     0     0     0      0         C.1.B097      C   B097\n#&gt; 4:     4     1     0     6     0      0         C.1.B097      C   B097\n#&gt; 5:     5     1     0     7    11      0         B.1.B089      B   B089\n#&gt; 6:     6     1     1     0     0      1         A.1.B080      A   B080\n\nThe example dataset contains:\n\nid: Individual unit identifier\nblockF: Block (cluster) factor\ntrtF: Treatment assignment factor (0 = control, 1 = treatment)\nY1, Y2: Outcome variables\nplace: Location identifier\nyear: Time identifier\nplace_year_block: Hierarchical grouping variable"
  },
  {
    "objectID": "hierarchical-testing-workflow.html#data-preparation",
    "href": "hierarchical-testing-workflow.html#data-preparation",
    "title": "Hierarchical Testing with manytestsr",
    "section": "Data Preparation",
    "text": "Data Preparation\nThe hierarchical testing approach requires both individual-level data (idat) and block-level summaries (bdat):\n\n# Individual-level data is already in the right format\nidat &lt;- as.data.table(example_dat)\nprint(paste(\"Number of individuals:\", nrow(idat)))\n#&gt; [1] \"Number of individuals: 1268\"\nprint(paste(\"Number of blocks:\", length(unique(idat$blockF))))\n#&gt; [1] \"Number of blocks: 44\"\n\n# Create block-level dataset with key variables\nbdat &lt;- idat %&gt;%\n  group_by(blockF) %&gt;%\n  summarize(\n    # Sample size\n    nb = n(),\n    # Proportion treated\n    pb = mean(trt),\n    # Harmonic mean weight (for testing power)\n    hwt = (nb / nrow(idat)) * (pb * (1 - pb)),\n    # Block characteristics\n    place = unique(place),\n    year = unique(year),\n    place_year_block = factor(unique(place_year_block)),\n    .groups = \"drop\"\n  ) %&gt;%\n  as.data.table()\n\nhead(bdat)\n#&gt;    blockF    nb        pb         hwt  place  year place_year_block\n#&gt;    &lt;fctr&gt; &lt;int&gt;     &lt;num&gt;       &lt;num&gt; &lt;char&gt; &lt;int&gt;           &lt;fctr&gt;\n#&gt; 1:   B080   129 0.6666667 0.022607781      A     1         A.1.B080\n#&gt; 2:   B081    68 0.6617647 0.012003618      A     1         A.1.B081\n#&gt; 3:   B082    56 0.6607143 0.009900293      A     1         A.1.B082\n#&gt; 4:   B083     8 0.6250000 0.001478707      A     1         A.1.B083\n#&gt; 5:   B084     9 0.7777778 0.001226779      A     2         A.2.B084\n#&gt; 6:   B085    53 0.6226415 0.009820844      A     3         A.3.B085\n\nKey block-level variables:\n\nhwt (harmonic mean weight): Measures testing power for each block\nnb (block size): Number of units in each block\npb (proportion treated): Treatment assignment rate\nplace_year_block: Hierarchical factor for pre-specified splits"
  },
  {
    "objectID": "hierarchical-testing-workflow.html#basic-hierarchical-testing",
    "href": "hierarchical-testing-workflow.html#basic-hierarchical-testing",
    "title": "Hierarchical Testing with manytestsr",
    "section": "Basic Hierarchical Testing",
    "text": "Basic Hierarchical Testing\n\nUsing Cluster-Based Splitting\nThe most common approach uses clustering to split blocks based on a continuous variable:\n\n# Run hierarchical testing with cluster-based splitting\nresults_cluster &lt;- find_blocks(\n  idat = idat,\n  bdat = bdat,\n  blockid = \"blockF\",\n  splitfn = splitCluster,  # Split using k-means clustering\n  pfn = pOneway,          # Use t-tests\n  fmla = Y1 ~ trtF | blockF,\n  splitby = \"hwt\",        # Split based on harmonic mean weights\n  parallel = \"no\",        # Disable parallel processing for demo\n  trace = TRUE,           # Show split progression\n  thealpha = 0.05\n)\n\n# Examine the structure\nstr(results_cluster, max.level = 1)\n#&gt; List of 2\n#&gt;  $ bdat    :Classes 'data.table' and 'data.frame':   44 obs. of  17 variables:\n#&gt;   ..- attr(*, \".internal.selfref\")=&lt;externalptr&gt; \n#&gt;   ..- attr(*, \"sorted\")= chr \"testable\"\n#&gt;  $ node_dat:Classes 'data.table' and 'data.frame':   1 obs. of  10 variables:\n#&gt;   ..- attr(*, \".internal.selfref\")=&lt;externalptr&gt;\n\n\n\nResults Overview\n\n# Block-level results\ncat(\"Block-level results structure:\\n\")\n#&gt; Block-level results structure:\ncat(\"Number of blocks:\", nrow(results_cluster$bdat), \"\\n\")\n#&gt; Number of blocks: 44\ncat(\"Variables:\", names(results_cluster$bdat), \"\\n\\n\")\n#&gt; Variables: blockF nb pb hwt place year place_year_block p1 pfinalb group_id node_id g1 alpha1 testable nodenum_current nodenum_prev blocksbygroup\n\n# Node-level results  \ncat(\"Node-level results structure:\\n\")\n#&gt; Node-level results structure:\ncat(\"Number of nodes:\", nrow(results_cluster$node_dat), \"\\n\")\n#&gt; Number of nodes: 1\ncat(\"Depth levels:\", sort(unique(results_cluster$node_dat$depth)), \"\\n\")\n#&gt; Depth levels: 1"
  },
  {
    "objectID": "hierarchical-testing-workflow.html#alternative-splitting-strategies",
    "href": "hierarchical-testing-workflow.html#alternative-splitting-strategies",
    "title": "Hierarchical Testing with manytestsr",
    "section": "Alternative Splitting Strategies",
    "text": "Alternative Splitting Strategies\n\nPre-specified Hierarchical Splitting\nWhen you have natural hierarchical structure, use factor-based splitting:\n\n# Use pre-specified hierarchical splits\nresults_hierarchical &lt;- find_blocks(\n  idat = idat,\n  bdat = bdat,\n  blockid = \"blockF\",\n  splitfn = splitSpecifiedFactor,\n  pfn = pIndepDist,        # Use distance-based test\n  fmla = Y2 ~ trtF | blockF,\n  splitby = \"place_year_block\",\n  parallel = \"no\",\n  trace = TRUE,\n  thealpha = 0.05\n)\n\nprint(paste(\"Hierarchical approach found\", \n           nrow(results_hierarchical$node_dat), \"nodes\"))\n#&gt; [1] \"Hierarchical approach found 5 nodes\"\n\n\n\nLeave-One-Out Splitting\nFocus testing on largest blocks first:\n\n# Leave-one-out approach\nresults_loo &lt;- find_blocks(\n  idat = idat,\n  bdat = bdat,\n  blockid = \"blockF\", \n  splitfn = splitLOO,\n  pfn = pOneway,\n  fmla = Y1 ~ trtF | blockF,\n  splitby = \"hwt\",  # Focus on blocks with highest power\n  parallel = \"no\",\n  thealpha = 0.05\n)\n\nprint(paste(\"LOO approach found\", \n           nrow(results_loo$node_dat), \"nodes\"))\n#&gt; [1] \"LOO approach found 1 nodes\""
  },
  {
    "objectID": "hierarchical-testing-workflow.html#sequential-error-rate-control",
    "href": "hierarchical-testing-workflow.html#sequential-error-rate-control",
    "title": "Hierarchical Testing with manytestsr",
    "section": "Sequential Error Rate Control",
    "text": "Sequential Error Rate Control\n\nAlpha Investing (FDR Control)\nFor more powerful testing with FDR control:\n\n# Use alpha investing for sequential FDR control\nresults_fdr &lt;- find_blocks(\n  idat = idat,\n  bdat = bdat,\n  blockid = \"blockF\",\n  splitfn = splitCluster,\n  pfn = pIndepDist,\n  alphafn = alpha_investing,  # Sequential FDR control\n  fmla = Y1 ~ trtF | blockF,\n  splitby = \"hwt\",\n  parallel = \"no\",\n  thealpha = 0.05,\n  thew0 = 0.049  # Starting wealth\n)\n\n# Compare alpha levels across approaches\nalpha_comparison &lt;- data.frame(\n  Node = 1:min(nrow(results_cluster$node_dat), nrow(results_fdr$node_dat)),\n  Fixed_Alpha = results_cluster$node_dat$a[1:min(nrow(results_cluster$node_dat), \n                                                nrow(results_fdr$node_dat))],\n  Adaptive_Alpha = results_fdr$node_dat$a[1:min(nrow(results_cluster$node_dat), \n                                               nrow(results_fdr$node_dat))]\n)\n\nprint(\"Alpha level comparison:\")\n#&gt; [1] \"Alpha level comparison:\"\nhead(alpha_comparison)\n#&gt;   Node Fixed_Alpha Adaptive_Alpha\n#&gt; 1    1        0.05           0.05"
  },
  {
    "objectID": "hierarchical-testing-workflow.html#detecting-significant-effects",
    "href": "hierarchical-testing-workflow.html#detecting-significant-effects",
    "title": "Hierarchical Testing with manytestsr",
    "section": "Detecting Significant Effects",
    "text": "Detecting Significant Effects\n\nUsing FWER Control\n\n# Detect significant blocks using FWER control\ndetections_fwer &lt;- report_detections(\n  results_cluster$bdat,\n  fwer = TRUE,\n  alpha = 0.05,\n  blockid = \"blockF\"\n)\n\n# Summary of detections\ncat(\"FWER Results:\\n\")\n#&gt; FWER Results:\ncat(\"Total blocks:\", nrow(detections_fwer), \"\\n\")\n#&gt; Total blocks: 44\ncat(\"Significant blocks:\", sum(detections_fwer$hit, na.rm = TRUE), \"\\n\")\n#&gt; Significant blocks: 0\ncat(\"Detection rate:\", \n    round(mean(detections_fwer$hit, na.rm = TRUE) * 100, 1), \"%\\n\\n\")\n#&gt; Detection rate: 0 %\n\n# Show significant blocks\nif(sum(detections_fwer$hit, na.rm = TRUE) &gt; 0) {\n  significant_blocks &lt;- detections_fwer[hit == TRUE, \n                                       .(blockF, pfinalb, fin_nodenum)]\n  print(\"Significant blocks:\")\n  print(significant_blocks)\n}\n\n\n\nUsing FDR Control\n\n# Detect using FDR control\ndetections_fdr &lt;- report_detections(\n  results_fdr$bdat,\n  fwer = FALSE,  # Use FDR instead\n  alpha = 0.05\n)\n\ncat(\"FDR Results:\\n\")\n#&gt; FDR Results:\ncat(\"Significant blocks:\", sum(detections_fdr$hit, na.rm = TRUE), \"\\n\")\n#&gt; Significant blocks: 44\ncat(\"Detection rate:\", \n    round(mean(detections_fdr$hit, na.rm = TRUE) * 100, 1), \"%\\n\")\n#&gt; Detection rate: 100 %"
  },
  {
    "objectID": "hierarchical-testing-workflow.html#visualizing-results",
    "href": "hierarchical-testing-workflow.html#visualizing-results",
    "title": "Hierarchical Testing with manytestsr",
    "section": "Visualizing Results",
    "text": "Visualizing Results\n\nTree Structure Visualization\n\n# Create tree structure for visualization\ntree_results &lt;- make_results_tree(\n  results_cluster$bdat, \n  block_id = \"blockF\",\n  node_label = \"hwt\"\n)\n\n# Create the graph visualization\ntree_plot &lt;- make_results_ggraph(tree_results$graph, remove_na_p = TRUE)\n\n# Customize the plot\ntree_plot_styled &lt;- tree_plot +\n  labs(\n    title = \"Hierarchical Testing Results Tree\",\n    subtitle = \"Nodes colored by p-values, size by block weight\",\n    caption = \"Red nodes indicate significant results\"\n  ) +\n  theme_void() +\n  theme(\n    plot.title = element_text(size = 14, hjust = 0.5),\n    plot.subtitle = element_text(size = 12, hjust = 0.5),\n    plot.caption = element_text(size = 10, hjust = 0.5)\n  )\n\nprint(tree_plot_styled)\n\n\n\n\n\n\n\n\n\n\nDetection Summary Plot\n\n# Compare detection rates across methods\ndetection_summary &lt;- data.frame(\n  Method = c(\"FWER (Cluster)\", \"FDR (Alpha Investing)\", \"FWER (Hierarchical)\", \"FWER (LOO)\"),\n  Detections = c(\n    sum(detections_fwer$hit, na.rm = TRUE),\n    sum(detections_fdr$hit, na.rm = TRUE),\n    sum(report_detections(results_hierarchical$bdat, fwer = TRUE)$hit, na.rm = TRUE),\n    sum(report_detections(results_loo$bdat, fwer = TRUE)$hit, na.rm = TRUE)\n  ),\n  Total_Blocks = c(\n    nrow(detections_fwer),\n    nrow(detections_fdr), \n    nrow(results_hierarchical$bdat),\n    nrow(results_loo$bdat)\n  )\n)\n\ndetection_summary$Detection_Rate &lt;- detection_summary$Detections / detection_summary$Total_Blocks\n\n# Create comparison plot\nggplot(detection_summary, aes(x = Method, y = Detection_Rate, fill = Method)) +\n  geom_col(alpha = 0.8) +\n  geom_text(aes(label = paste0(Detections, \"/\", Total_Blocks)), \n            vjust = -0.5, size = 3) +\n  labs(\n    title = \"Detection Rates Across Testing Methods\",\n    y = \"Proportion of Blocks with Detected Effects\",\n    x = \"Testing Method\"\n  ) +\n  scale_y_continuous(labels = scales::percent_format()) +\n  theme_minimal() +\n  theme(\n    axis.text.x = element_text(angle = 45, hjust = 1),\n    legend.position = \"none\"\n  )"
  },
  {
    "objectID": "hierarchical-testing-workflow.html#interpreting-p-values-and-alpha-levels",
    "href": "hierarchical-testing-workflow.html#interpreting-p-values-and-alpha-levels",
    "title": "Hierarchical Testing with manytestsr",
    "section": "Interpreting P-values and Alpha Levels",
    "text": "Interpreting P-values and Alpha Levels\n\nP-value Progression Through Tree\n\n# Examine p-value patterns\npvalue_data &lt;- results_cluster$node_dat[, .(\n  nodenum, \n  depth, \n  p, \n  a,\n  testable,\n  nodesize\n)]\n\n# Show how p-values change with depth\npvalue_summary &lt;- pvalue_data[!is.na(p), .(\n  Mean_P = mean(p),\n  Median_P = median(p),\n  Mean_Alpha = mean(a),\n  N_Nodes = .N\n), by = depth]\n\nprint(\"P-value progression by tree depth:\")\n#&gt; [1] \"P-value progression by tree depth:\"\nprint(pvalue_summary)\n#&gt;    depth     Mean_P   Median_P Mean_Alpha N_Nodes\n#&gt;    &lt;int&gt;      &lt;num&gt;      &lt;num&gt;      &lt;num&gt;   &lt;int&gt;\n#&gt; 1:     1 0.05971615 0.05971615       0.05       1\n\n\n\nStatistical Power Analysis\n\n# Analyze relationship between block characteristics and detection\npower_data &lt;- merge(\n  detections_fwer[, .(blockF, hit, pfinalb)],\n  bdat[, .(blockF, hwt, nb, pb)],\n  by = \"blockF\"\n)\n\n# Power vs. block size\np1 &lt;- ggplot(power_data, aes(x = nb, y = -log10(pfinalb), color = hit)) +\n  geom_point(alpha = 0.7, size = 2) +\n  scale_color_manual(values = c(\"FALSE\" = \"blue\", \"TRUE\" = \"red\")) +\n  labs(\n    title = \"Detection by Block Size\",\n    x = \"Block Size (number of units)\",\n    y = \"-log10(p-value)\",\n    color = \"Detected\"\n  ) +\n  theme_minimal()\n\n# Power vs. harmonic mean weight\np2 &lt;- ggplot(power_data, aes(x = hwt, y = -log10(pfinalb), color = hit)) +\n  geom_point(alpha = 0.7, size = 2) +\n  scale_color_manual(values = c(\"FALSE\" = \"blue\", \"TRUE\" = \"red\")) +\n  labs(\n    title = \"Detection by Harmonic Mean Weight\", \n    x = \"Harmonic Mean Weight\",\n    y = \"-log10(p-value)\",\n    color = \"Detected\"\n  ) +\n  theme_minimal()\n\n# Combine plots\nlibrary(patchwork)\np1 + p2 + plot_layout(ncol = 2)"
  },
  {
    "objectID": "hierarchical-testing-workflow.html#advanced-usage-multiple-outcomes",
    "href": "hierarchical-testing-workflow.html#advanced-usage-multiple-outcomes",
    "title": "Hierarchical Testing with manytestsr",
    "section": "Advanced Usage: Multiple Outcomes",
    "text": "Advanced Usage: Multiple Outcomes\n\nTesting Multiple Outcomes\n\n# Test both outcomes with local p-value adjustment\nresults_multi_Y1 &lt;- find_blocks(\n  idat = idat,\n  bdat = bdat,\n  blockid = \"blockF\",\n  splitfn = splitCluster,\n  pfn = pIndepDist,\n  local_adj_p_fn = local_simes,  # Simes adjustment within nodes\n  fmla = Y1 ~ trtF | blockF,\n  splitby = \"hwt\",\n  parallel = \"no\",\n  thealpha = 0.05\n)\n\nresults_multi_Y2 &lt;- find_blocks(\n  idat = idat,\n  bdat = bdat,\n  blockid = \"blockF\",\n  splitfn = splitCluster,\n  pfn = pIndepDist,\n  local_adj_p_fn = local_simes,\n  fmla = Y2 ~ trtF | blockF,\n  splitby = \"hwt\",\n  parallel = \"no\",\n  thealpha = 0.05\n)\n\n# Compare results\nmulti_comparison &lt;- data.frame(\n  Outcome = c(\"Y1\", \"Y2\"),\n  Nodes = c(nrow(results_multi_Y1$node_dat), nrow(results_multi_Y2$node_dat)),\n  Detections = c(\n    sum(report_detections(results_multi_Y1$bdat)$hit, na.rm = TRUE),\n    sum(report_detections(results_multi_Y2$bdat)$hit, na.rm = TRUE)\n  )\n)\n\nprint(\"Multiple outcome comparison:\")\n#&gt; [1] \"Multiple outcome comparison:\"\nprint(multi_comparison)\n#&gt;   Outcome Nodes Detections\n#&gt; 1      Y1    11         42\n#&gt; 2      Y2    11         42"
  },
  {
    "objectID": "hierarchical-testing-workflow.html#summary-and-best-practices",
    "href": "hierarchical-testing-workflow.html#summary-and-best-practices",
    "title": "Hierarchical Testing with manytestsr",
    "section": "Summary and Best Practices",
    "text": "Summary and Best Practices\n\nKey Takeaways\n\nSplitting Strategy Choice:\n\nCluster-based (splitCluster): Good for continuous block characteristics\nHierarchical (splitSpecifiedFactor): Use when you have natural hierarchical structure\nLeave-one-out (splitLOO): Focus on highest-power blocks first\n\nError Rate Control:\n\nFixed alpha: Simple FWER control\nAlpha investing: More powerful FDR control\nSAFFRON/ADDIS: Alternative sequential procedures\n\nTest Function Selection:\n\npOneway: Standard t-tests, good for normal outcomes\npIndepDist: Distance-based tests, robust to distributions\npWilcox: Rank-based tests, good for ordinal outcomes\n\n\n\n\nRecommended Workflow\n\n# 1. Prepare data\nidat &lt;- your_individual_data\nbdat &lt;- create_block_summary(idat)\n\n# 2. Choose approach based on data structure\nif(have_hierarchical_structure) {\n  splitfn &lt;- splitSpecifiedFactor\n  splitby &lt;- \"hierarchical_variable\"\n} else {\n  splitfn &lt;- splitCluster  \n  splitby &lt;- \"power_variable\"  # e.g., block size or weights\n}\n\n# 3. Run hierarchical testing\nresults &lt;- find_blocks(\n  idat = idat,\n  bdat = bdat,\n  splitfn = splitfn,\n  pfn = pIndepDist,  # Robust choice\n  alphafn = alpha_investing,  # For more power\n  splitby = splitby,\n  thealpha = 0.05\n)\n\n# 4. Detect significant effects\ndetections &lt;- report_detections(results$bdat, fwer = FALSE)  # FDR control\n\n# 5. Visualize results\ntree &lt;- make_results_tree(results$bdat, block_id = \"block_variable\")\nplot &lt;- make_results_ggraph(tree$graph)\n\n\n\nPerformance Considerations\n\nUse parallel = \"multicore\" for faster computation on multi-core systems\nSet appropriate simthresh to balance accuracy vs.Â speed\nConsider maxtest to limit tree depth in very large datasets\nUse trace = TRUE during development to monitor progress\n\nThis hierarchical testing framework provides a principled approach to multiple testing while maintaining interpretability and controlling error rates. The flexible design allows adaptation to various experimental contexts and research questions."
  }
]