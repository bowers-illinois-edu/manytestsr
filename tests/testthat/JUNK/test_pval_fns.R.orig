# Test and develop functions to produce p-values.
# Focusing especially on test statistics that will not allow positive and negative effects to cancel out
context("Performance of  P-value Functions")

library(data.table)
library(testthat)
library(here)
library(coin)
source(here("tests/testthat","make_test_data.R"))
devtools::load_all()

##  We have Y where the effects  are gigantic within  block and canceling
## Ynull where the sharp  null is  true
## Yhomog where all blocks have additive  constant effect of  5
## And Ynormb where blocks have hetergeneous  effects following a normal  dist within block
## We want a procedure that, for Y, rejects the null both within any given block as well as across blocks.
##  The simple tests fail to achieve this goal
# oneway_test(Y~ZF|bF,data=idat) ## what we do not  want
# oneway_test(Y~ZF|bF,data=b1) ## what we want
# wilcox_test(Y~ZF|bF,data=idat) ## what we do not  want
# wilcox_test(Y~ZF|bF,data=b1) ## what we want

# b1 is block level
# idat is individual level


### ## Neither of these should detect effects
set.seed(12345)
idat[,Z:=sample(Z),by=bF]
idat[,ZF:=factor(Z,labels=c(0,1))]

## This next does not work
idat[,c("e_i1","e_i2","e_i3","rankY"):=c(ctrldist(Ynull,Z),
                                        list(Rfast::Rank(Ynull))),by=bF]
it1a <- independence_test(e_i1+e_i2+e_i3+Ynull+rankY~Z|bF,data=idat,teststat="quadratic")
pvalue(it1a)
statistic(it1a,type="linear")
expectation(it1a)
covariance(it1a)
cov2cor(covariance(it1a))

it1b <- independence_test(Ynull~Z|bF,data=idat,teststat="quadratic")
pvalue(it1b)
it1c <- independence_test(e_i1~Z|bF,data=idat,teststat="quadratic")
pvalue(it1c)
it1d <- independence_test(e_i2~Z|bF,data=idat,teststat="quadratic")
pvalue(it1d)
it1e <- independence_test(e_i3~Z|bF,data=idat,teststat="quadratic")
pvalue(it1e)

idat[,c("e_Y_i1","e_Y_i2","e_Y_i3","rankY_Y"):=c(ctrldist(Y,Z),
                                        list(Rfast::Rank(Y))),by=bF]
itYa <- independence_test(e_Y_i1+e_Y_i3+I(rank(e_Y_i3))+Y+rankY_Y~Z|bF,data=idat,teststat="quadratic")
pvalue(itYa) # this should be small. the other ones should be big.


b1 <- droplevels(idat[bF==1,])
it0a <- independence_test(Ynull+rankY~Z,data=b1,teststat="quadratic")
statistic(it0a)
statistic(it0a,type="linear")
statistic(it0a,type="standardized")
b1[,.(sum(Ynull*Z),sum(rankY*Z))]
it0b <- independence_test(Ynull+rankY~ZF,data=b1,teststat="quadratic")
statistic(it0b,type="linear")
b1[,.(sum(Ynull * (ZF=="0")),sum(rankY * (ZF=="0")))]
statistic(it0b,type="standardized")
statistic(it0b)

xb0a <- RItools::xBalance(Z~Ynull+rankY,data=b1,report="all")
<<<<<<< HEAD
xb0a$results
xb0a$overall
=======
xb0a
xb0b <- RItools::xBalance(Z~Ynull+rankY+e_i1+e_i2+e_i3,data=b1,report="all")
xb0b
>>>>>>> 130804d9984358db34b8b2b05a512b4618f5039c

setorder(b1,Z)
b0 <- as.data.frame(b1)
b0 <- b0[c(1:5,95:100),]
ctrldist(b0$Ynull,b0$Z)
dx <- Dist(b0$Ynull)
dz <- outer(b0$Z,b0$Z,function(x,y){ abs(x - y) })
M <- cbind(b0$Z,(1-b0$Z))
M_sums <- dx %*% M
Mxy_sums <- (M_sums * (1-M)) %*% c(1,1)
Mxx_sums <- (M_sums * M) %*% c(1,1)

Mij_i <- rowSums(dx)
Mii_i <- rowSums(dx)
blah <- edist(dist(b1$Ynull),sizes=c(50,50))
blah <- ksample.e(dist(b1$Ynull),sizes=c(50,50),distance=TRUE)
blah2 <- ksample.e(dist(b1$Ynull),sizes=c(50,50),distance=TRUE,method="discoF")
blah3 <- ksample.e(dist(b1$Ynull),sizes=c(50,50),distance=TRUE,method="discoB") ## original*2 because uses full sample denom

#xb1 <- RItools::xBalance(Z~rankY+rank_e_i+e_i+Ynull,strata=list(bf=~bF),data=idat,report="all")
#xb1$overall
#expect_equal(pvalue(it1a)[[1]],xb1$overall[,3])

res_null_idat <- pIndepDist(dat = idat, fmla = Ynull ~ Z | bF, distfn = ctrldist)
res_null_idat

it4a <- independence_test(rankY~ZF|bF,data=idat,teststat="quadratic")
it4b <- independence_test(rank_e_i~ZF|bF,data=idat,teststat="quadratic")
it4c <- independence_test(e_i~ZF|bF,data=idat,teststat="quadratic")
it4d <- independence_test(Ynull~ZF|bF,data=idat,teststat="quadratic")
pvalue(it4a)
pvalue(it4b)
pvalue(it4c)
pvalue(it4d)

## ## This works but breaks the Z to outcome transformed reelationship directly.
## nsims <- 1000
## ps <- rep(NA,length=nsims)
## for(i in 1:nsims){
##   it2 <- independence_test(rankY+rank_e_i+e_i+Ynull~ZF|bF,data=idat[,ZF:=sample(ZF),by=bF],teststat="quadratic")
##   ps[i] <- pvalue(it2)
## }
## mean(ps < .05)
## hist(ps)

## This does not because Z is not breaking its relationship directly with the Distances
nsims <- 1000
ps2 <- rep(NA,nsims)
for(i in 1:nsims){
  ps2[i]<- pIndepDist(fmla=Ynull~newZ|bF,dat=idat[,newZ:=sample(Z),by=bF],distfn=ctrldist)
}
mean(ps2 < .05)
hist(ps2)

## This does not because Z is not breaking its relationship directly with the Distances
nsims <- 1000
thepsbig <- matrix(NA,ncol=nsims,nrow=6)
for(i in 1:nsims){
	idat[,newZ:=sample(Z),by=bF]
	idat[,c("e_i1","e_i2","e_i3","e_i4","e_i5","rankY"):=c(ctrldist(Ynull,newZ),
							 list(Rfast::Rank(Ynull))),by=bF]
	idat[,newZF:=factor(newZ)]
	thepsbig[1,i] <- pvalue(independence_test(e_i1~newZF|bF,data=idat,teststat="quadratic"))
	thepsbig[2,i] <- pvalue(independence_test(e_i2~newZF|bF,data=idat,teststat="quadratic"))
	thepsbig[3,i] <- pvalue(independence_test(e_i3~newZF|bF,data=idat,teststat="quadratic"))
	thepsbig[4,i] <- pvalue(independence_test(e_i4~newZF|bF,data=idat,teststat="quadratic"))
	thepsbig[5,i] <- pvalue(independence_test(e_i5~newZF|bF,data=idat,teststat="quadratic"))
	thepsbig[6,i] <- pvalue(independence_test(Ynull~newZF|bF,data=idat,teststat="quadratic"))
}
apply(thepsbig,1,function(x){ mean(x < .05) })

nsims <- 10
theps <- matrix(NA,ncol=nsims,nrow=6)
for(i in 1:nsims){
	b1[,newZ:=sample(Z)]
	b1[,c("e_i1","e_i2","e_i3","e_i4","e_i5","rankY"):=c(ctrldist(Ynull,newZ),
							 list(Rfast::Rank(Ynull)))]
	b1[,newZF:=factor(newZ)]
	theps[1,i] <- pvalue(independence_test(e_i1~newZF,data=b1,teststat="quadratic"))
	theps[2,i] <- pvalue(independence_test(e_i2~newZF,data=b1,teststat="quadratic"))
	theps[3,i] <- pvalue(independence_test(e_i3~newZF,data=b1,teststat="quadratic"))
	theps[4,i] <- pvalue(independence_test(e_i4~newZF,data=b1,teststat="quadratic"))
	theps[5,i] <- pvalue(independence_test(e_i5~newZF,data=b1,teststat="quadratic"))
	theps[6,i] <- pvalue(independence_test(Ynull~newZF,data=b1,teststat="quadratic"))
}
apply(theps,1,function(x){ mean(x < .05) })
## Notes: e_i2 and e_i3 produce same p values, also e_i4 and e_i5 produce same
## pvalues


idat$y1test_null<-create_effects(idat=idat,ybase = 'y0', blockid='bF',tau_fn = tau_norm, tau_size=0, prop_blocks_0 = 1,covariate='vb1')
expect_equal(idat$y1test_null,idat$y0)
idat[,Ynull2:=Z*y1test_null+(1-Z)*y0]
expect_equal(idat$Ynull2,idat$y0)
all.equal(idat$Ynull,idat$Ynull2)

idat$y0_simp <- rnorm(nrow(idat),mean=0,sd=1)
idat$y1_simp <- idat$y0_simp
idat$Y_simp <- idat$y0_simp




idat3[,rank_e_i:=list(ctrldist(Ynull,Z)),by=bF]
idat3[,rankY:=Rfast::Rank(Ynull),by=bF]
it99 <- independence_test(rankY+rank_e_i+Ynull~as.factor(Z)|bF,data=idat3,teststat="quadratic")
xb99 <- RItools::xBalance(Z~rankY+rank_e_i+Ynull,strata=list(bf=~bF),data=idat3,report="all")
pvalue(it99)
xb99$overall

cors<-idat[,{thecor<-cor(.SD);max(thecor[lower.tri(thecor)])},by=bF,.SDcols=c("rankY","e_i","rank_e_i","Ynull")]


res_null_idat3 <- pIndepDist(dat = idat3, fmla = Ynull ~ ZF | bF, distfn = ctrldist)


#it2 <- independence_test(rankY+rank_e_i+Y_simp~as.factor(Z),data=droplevels(idat[bF==5,]),teststat="quadratic")
#xb2 <- RItools::xBalance(Z~rankY+rank_e_i+Y_simp,data=droplevels(idat[bF==5,]),report="all")
#pvalue(it2)
#xb2$overall

ps <-idat[,pvalue(independence_test(rankY+rank_e_i+Y_simp~as.factor(Z),data=droplevels(.SD),teststat="quadratic")),by=bF]
psXB <-idat[,RItools::xBalance(Z~rankY+rank_e_i+Y_simp,data=droplevels(.SD),report="all")$overall,by=bF]
cbind(psXB,ps)

cors<-idat[,{thecor<-cor(.SD);max(thecor[lower.tri(thecor)])},by=bF,.SDcols=c("rankY","rank_e_i","Y_simp")]

thecor <- cor(data.frame(idat[bF==6,.(rankY,rank_e_i,Ynull)]))
max(thecor[lower.tri(thecor,diag=FALSE)])

summary(idat[bF==6,.(Z,rankY,rank_e_i,Ynull)])
summary(idat[bF==7,.(Z,rankY,rank_e_i,Ynull)])

ctrldist(idat[bF==6,Ynull],idat[bF==6,Z])


test_that("pIndepDist works as expected", {
  res_cancel_idat <- pIndepDist(dat = idat, fmla = Y ~ ZF | bF, distfn = ctrldist)
  res_cancel_b1 <- pIndepDist(dat = b1, fmla = Y ~ ZF | bF, distfn = ctrldist)
  res_null_idat <- pIndepDist(dat = idat, fmla = Ynull ~ ZF | bF, distfn = ctrldist)
  res_null_idat3 <- pIndepDist(dat = idat3, fmla = Ynull ~ ZF | bF, distfn = ctrldist)
  ## res_null2_idat <- pIndepDist(dat = idat, fmla = Ynull2 ~ ZF | bF, distfn = ctrldist)
  ## res_null_idat_T <- pOneway(dat = idat, fmla = Ynull ~ ZF | bF)
  res_null_b1 <- pIndepDist(dat = b1, fmla = Ynull ~ ZF | bF, distfn = ctrldist)
  res_homog_idat <- pIndepDist(dat = idat, fmla = Yhomog ~ ZF | bF, distfn = ctrldist)
  res_homog_b1 <- pIndepDist(dat = b1, fmla = Yhomog ~ ZF | bF, distfn = ctrldist)
  res_normb_idat <- pIndepDist(dat = idat, fmla = Ynormb ~ ZF | bF, distfn = ctrldist)
  res_normb_b1 <- pIndepDist(dat = b1, fmla = Ynormb ~ ZF | bF, distfn = ctrldist)
  expect_lt(res_cancel_idat, .05)
  expect_lt(res_cancel_b1, .05)
  expect_gt(res_null_idat, .05)
  expect_gt(res_null_idat3, .05)
  expect_gt(res_null_b1, .05)
  expect_lt(res_homog_idat, .05)
  expect_lt(res_homog_b1, .05)
  expect_lt(res_normb_idat, .05)
  expect_lt(res_normb_b1, .05)
})

test_that("Ordinary tests do not reject when effects cancel across blocks", {
  expect_gt(pvalue(oneway_test(Y ~ ZF | bF, data = idat)), .05)
  expect_gt(pvalue(wilcox_test(Y ~ ZF | bF, data = idat)), .05)
})

test_that("Ordinary tests do reject when effects are large within blocks even if they cancel across blocks", {
  expect_lt(max(idat[, list(p = pvalue(wilcox_test(Y ~ ZF, data = .SD))), by = b]$p), .05)
})

test_that("passing a block factor to a p-value function with one block gives the same results as  omitting it",{
  res_cancel_b1_block <- pIndepDist(dat = b1, fmla = Y ~ ZF | bF, distfn = ctrldist)
  res_cancel_b1_noblock <- pIndepDist(dat = b1, fmla = Y ~ ZF, distfn = ctrldist)
  expect_equal(res_cancel_b1_block,res_cancel_b1_block)
  res_null_b1_block <- pIndepDist(dat = b1, fmla = Ynull ~ ZF | bF, distfn = ctrldist)
  res_null_b1_noblock <- pIndepDist(dat = b1, fmla = Ynull ~ ZF, distfn = ctrldist)
  expect_equal(res_null_b1_block,res_null_b1_block)
}
)
