% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/pval_fns.R
\name{pTestTwice}
\alias{pTestTwice}
\title{P-value function: Testing twice}
\usage{
pTestTwice(
  dat,
  fmla = YcontNorm ~ trtF | blockF,
  simthresh = 20,
  sims = 1000,
  parallel = "yes",
  ncpu = NULL,
  groups = NULL
)
}
\arguments{
\item{dat}{An object inheriting from class data.frame}

\item{fmla}{A formula  appropriate to the function. Here it should  be something like outcome~treatment|block}

\item{simthresh}{is the size of the data below which we use direct permutations for p-values}

\item{sims}{Either NULL (meaning use an asymptotic reference dist) or a
number (meaning sampling from the randomization distribution implied by the
formula)}

\item{parallel}{is "no" then parallelization is not required, otherwise it
is "multicore" or "snow" in the call to \code{coin::independence_test()} (see
help for coin::approximate()). Also, if parallel is not "no" and
\code{adaptive_dist_function} is TRUE, then an openmp version of the distance
creation function is called using \code{ncpu} threads (or
\code{parallel::detectCores(logical=FALSE)} cores).}

\item{ncpu}{is number of cpus  to be used for parallel operation.}

\item{groups}{Currently unused parameter, reserved for future functionality}
}
\value{
A p-value
}
\description{
These functions accept a data frame and perhaps test specific
arguments (like whether or not the test will be asymptotic or simulation
based). It produces a p-value.
}
\details{
For now, this  function  does an omnibus-style max-T test using (1)
the raw outcome and (2) a rank transformed raw outcome. Inspired by Rosenbaum (2008) on Testing Twicee
}
