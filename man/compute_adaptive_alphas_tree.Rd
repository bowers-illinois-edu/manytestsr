% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/alpha_adaptive.R
\name{compute_adaptive_alphas_tree}
\alias{compute_adaptive_alphas_tree}
\title{Compute Adaptive Alpha Levels from an Actual Tree}
\usage{
compute_adaptive_alphas_tree(
  node_dat,
  delta_hat,
  max_depth = NULL,
  thealpha = 0.05
)
}
\arguments{
\item{node_dat}{A data.frame or data.table with columns
\code{nodenum}, \code{parent}, \code{depth}, and \code{nodesize}.
Typically extracted from a \code{\link{find_blocks}} result.
The root node must have \code{parent = 0} and \code{depth = 1}.}

\item{delta_hat}{Estimated standardized effect size (e.g., Cohen's d).
Conservative (larger) values produce more stringent adjustment,
which preserves the FWER guarantee.}

\item{max_depth}{Maximum depth to compute. Defaults to the maximum
depth present in \code{node_dat}.}

\item{thealpha}{Nominal significance level (default 0.05).}
}
\value{
Named numeric vector of adjusted alpha levels, one per depth
(1 through \code{max_depth}). Names are depth levels as characters.
Has attribute \code{"error_load"} containing the
\code{\link{compute_error_load}} result from the tree.
}
\description{
Tree-mode counterpart to \code{\link{compute_adaptive_alphas}}. Instead
of assuming a regular k-ary tree with equal splits, this function takes
the actual tree structure (with per-node sample sizes) and computes
per-depth adjusted significance levels. This handles irregular trees
where branching factor and sample sizes vary across nodes.
}
\details{
The algorithm mirrors \code{\link{compute_adaptive_alphas}} but uses
actual per-node power instead of the parametric assumption:

\enumerate{
\item Compute per-node power \eqn{\theta} and path power
(product of ancestor thetas) via \code{compute_error_load}.
\item If total error load \eqn{\sum G_\ell \le 1}: natural gating
suffices, return nominal \code{thealpha} at every depth.
\item Otherwise, at depth \eqn{d}:
\deqn{\alpha_d = \min\left\{\alpha,\;
      \frac{\alpha}{\sum_{\text{nodes at depth } d}
        \text{path\_power}(\text{node})} \right\}}
}

The denominator at depth \eqn{d} is the sum of path powers over all
nodes at that depth --- i.e., the expected number of tests the
procedure conducts at depth \eqn{d}. For a regular k-ary tree with
equal sample sizes, this reduces to
\eqn{k^{d-1} \prod_{j=1}^{d-1} \theta_j}, matching the parametric
formula in \code{\link{compute_adaptive_alphas}}.
}
\examples{
# Build a small irregular tree
nd <- data.frame(
  nodenum  = 1:7,
  parent   = c(0, 1, 1, 2, 2, 3, 3),
  depth    = c(1, 2, 2, 3, 3, 3, 3),
  nodesize = c(500, 250, 250, 125, 125, 100, 150)
)
compute_adaptive_alphas_tree(node_dat = nd, delta_hat = 0.5)

}
