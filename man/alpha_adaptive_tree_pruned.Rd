% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/alpha_adaptive.R
\name{alpha_adaptive_tree_pruned}
\alias{alpha_adaptive_tree_pruned}
\title{Adaptive Alpha with Branch Pruning}
\usage{
alpha_adaptive_tree_pruned(node_dat, delta_hat, max_depth = NULL)
}
\arguments{
\item{node_dat}{A data.frame or data.table with columns
\code{nodenum}, \code{parent}, \code{depth}, and \code{nodesize}.
Typically extracted from a \code{\link{find_blocks}} result.
The root node must have \code{parent = 0} and \code{depth = 1}.}

\item{delta_hat}{Estimated standardized effect size (e.g., Cohen's d).
Conservative (larger) values produce more stringent adjustment,
which preserves the FWER guarantee.}

\item{max_depth}{Maximum depth to compute. Defaults to the maximum
depth present in \code{node_dat}.}
}
\value{
A list with three components:
\describe{
\item{\code{alphafn}}{A function with the standard alphafn
interface: \code{function(pval, batch, nodesize, thealpha,
    thew0, depth)}. Looks up the current alpha schedule by depth.}
\item{\code{update}}{A function
\code{function(pruned_node_dat, thealpha)} that recomputes
the alpha schedule on the given (pruned) tree. Called by
\code{find_blocks} after each depth's testable decisions.}
\item{\code{reset}}{A function \code{function(thealpha)} that
restores the alpha schedule to the full (unpruned) tree.
Called by \code{find_blocks} at the start of each run to
ensure independence across simulation iterations.}
}
}
\description{
Factory function that creates an adaptive alpha adjustment system
supporting branch pruning. Unlike \code{\link{alpha_adaptive_tree}},
which pre-computes a fixed schedule, this version can recompute the
schedule on a pruned subtree after each depth --- giving more alpha
to surviving branches when dead branches are removed.
}
\details{
The FWER guarantee follows from the same telescoping-sum argument
as \code{\link{alpha_adaptive_tree}}, applied to the surviving
subtree at each depth. Pruning decisions at depth \eqn{d} depend
only on tests at depths \eqn{1, \ldots, d}, which are independent
of tests at deeper levels (under data splitting or independent
permutation tests), so the conditional FWER bound holds.

When \code{find_blocks} detects a list-valued \code{alphafn},
it extracts these three components and calls \code{reset} at
the start of each run and \code{update} after each depth.
}
\examples{
nd <- data.frame(
  nodenum  = 1:7,
  parent   = c(0, 1, 1, 2, 2, 3, 3),
  depth    = c(1, 2, 2, 3, 3, 3, 3),
  nodesize = c(500, 250, 250, 125, 125, 100, 150)
)
obj <- alpha_adaptive_tree_pruned(node_dat = nd, delta_hat = 0.5)
# obj$alphafn — pass to find_blocks
# obj$update(pruned_nd, 0.05) — recompute on surviving tree
# obj$reset(0.05) — restore full-tree schedule

}
