% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/alpha_adaptive.R
\name{compute_error_load}
\alias{compute_error_load}
\title{Compute Error Load for Natural Gating Assessment}
\usage{
compute_error_load(
  k = NULL,
  delta_hat,
  N_total = NULL,
  node_dat = NULL,
  max_depth = 20L,
  thealpha = 0.05
)
}
\arguments{
\item{k}{Branching factor. Either a scalar (constant k at all levels)
or an integer vector of length \code{max_depth} where \code{k[ell]}
is the branching factor at level \code{ell}. Used in parametric mode;
ignored when \code{node_dat} is provided.}

\item{delta_hat}{Estimated standardized effect size (e.g., Cohen's d).
Used to compute power at each level via the normal approximation.}

\item{N_total}{Total sample size at the root level. Used in parametric
mode; ignored when \code{node_dat} is provided.}

\item{node_dat}{Optional data.frame or data.table with columns
\code{nodenum}, \code{parent}, \code{depth}, and \code{nodesize}.
When provided, the function computes per-node power from
\code{nodesize} and aggregates error load by depth. This supports
irregular trees (e.g., DPP design with unequal splits).}

\item{max_depth}{Maximum tree depth to compute. In parametric mode,
defaults to 20. In tree mode, inferred from \code{node_dat}.}

\item{thealpha}{Nominal significance level (default 0.05).}
}
\value{
A named list with components:
\describe{
\item{\code{G}}{Numeric vector of error load at each level
(length \code{max_depth}).}
\item{\code{sum_G}}{Total error load: \code{sum(G)}.}
\item{\code{needs_adjustment}}{Logical: \code{TRUE} when
\code{sum_G > 1}.}
\item{\code{thetas}}{Estimated power (conditional rejection
probability) at each level.}
\item{\code{critical_level}}{First level where theta < 1/k
(where natural gating begins to dominate), or \code{NA} if
theta never drops below 1/k.}
\item{\code{n_by_level}}{Sample size at each level.}
}
}
\description{
Computes the error load at each tree level, which measures the expected
number of all-null sibling groups tested. When the total error load is
at most 1, the unadjusted procedure (fixed alpha at every node) controls
FWER at level alpha --- no adjustment needed. When it exceeds 1, adaptive
alpha adjustment is required.
}
\details{
Two interfaces are provided. The \strong{parametric} interface
(\code{k}, \code{delta_hat}, \code{N_total}) assumes a regular k-ary
tree with equal splitting: sample size at level ell is
\eqn{N / k^{ell-1}}. The \strong{tree} interface
(\code{node_dat}) accepts per-node sample sizes from an actual
(possibly irregular) tree, as returned by \code{\link{find_blocks}}.

In \strong{parametric mode}, the error load at level ell is:
\deqn{G_\ell = k^{\ell-1} \prod_{j=0}^{\ell-1} \theta_j}
where \eqn{\theta_j = \Phi(\delta \sqrt{n_j} - z_{1-\alpha/2})}
and \eqn{n_j = N / k^{j}}.

In \strong{tree mode}, the function computes per-node power from
the actual sample sizes. For each node at depth d, it computes
\eqn{\theta = \Phi(\delta \sqrt{n_{\text{node}}} - z_{1-\alpha/2})}.
The error load at depth d is the sum over all nodes at depth d of the
product of theta values along the path from root to that node's parent,
which generalizes the regular-tree formula to irregular branching.
}
\examples{
# Parametric mode: regular 3-ary tree, moderate effect
compute_error_load(k = 3, delta_hat = 0.3, N_total = 500)

# High power, wide tree: needs adjustment
res <- compute_error_load(k = 10, delta_hat = 0.5, N_total = 5000,
                          max_depth = 3)
res$sum_G     # likely > 1
res$needs_adjustment

}
